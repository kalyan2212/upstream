name: Deploy Upstream App to Azure
# ─────────────────────────────────────────────────────────────────────────────
# Triggers: every push to main branch
# Steps:
#   1. Provision Azure infrastructure with Terraform
#   2. Deploy app files to both VMs via SSH
#   3. Restart the Streamlit service on each VM
# ─────────────────────────────────────────────────────────────────────────────

on:
  push:
    branches:
      - "main"
  workflow_dispatch:          # allow manual trigger from GitHub UI

env:
  # Terraform Azure backend auth
  ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET:   ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
  # Terraform variables
  TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  TF_VAR_ssh_public_key:  ${{ secrets.SSH_PUBLIC_KEY }}
  TF_VAR_vm_size:         "Standard_D2s_v3"

jobs:
  # ── Job 1: Terraform ────────────────────────────────────────────────────────
  terraform:
    name: Provision Infrastructure
    runs-on: ubuntu-latest
    outputs:
      vm1_ip: ${{ steps.tf_out.outputs.vm1_ip }}
      vm2_ip: ${{ steps.tf_out.outputs.vm2_ip }}
      lb_ip:  ${{ steps.tf_out.outputs.lb_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.7.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform Plan
        working-directory: terraform
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Capture Terraform Outputs
        id: tf_out
        working-directory: terraform
        run: |
          echo "vm1_ip=$(terraform output -raw vm1_public_ip)" >> "$GITHUB_OUTPUT"
          echo "vm2_ip=$(terraform output -raw vm2_public_ip)" >> "$GITHUB_OUTPUT"
          echo "lb_ip=$(terraform output -raw lb_public_ip)"   >> "$GITHUB_OUTPUT"

      - name: Print App URL
        working-directory: terraform
        run: |
          echo "=============================================="
          echo " App is accessible at: $(terraform output -raw app_url)"
          echo "=============================================="

  # ── Job 2: Deploy App ───────────────────────────────────────────────────────
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: terraform

    strategy:
      matrix:
        vm_ip:
          - ${{ needs.terraform.outputs.vm1_ip }}
          - ${{ needs.terraform.outputs.vm2_ip }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure SSH key
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Verify the key is unencrypted; exit early with a clear message if not
          if ! ssh-keygen -y -P "" -f ~/.ssh/id_rsa > /dev/null 2>&1; then
            echo "ERROR: SSH_PRIVATE_KEY is passphrase-protected or invalid."
            echo "GitHub Actions requires an unencrypted private key in the SSH_PRIVATE_KEY secret."
            echo "Please replace the secret with an unencrypted key and re-run the workflow."
            exit 1
          fi
          ssh-keyscan -H "${{ matrix.vm_ip }}" >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Inject SSH public key to VM via Azure
        run: |
          az login --service-principal \
            -u "$ARM_CLIENT_ID" \
            -p "$ARM_CLIENT_SECRET" \
            --tenant "$ARM_TENANT_ID" \
            --output none
          PUB_KEY=$(ssh-keygen -y -P "" -f ~/.ssh/id_rsa)
          VM_NAME=$(az vm list -d \
            --resource-group "rg-upstream-prod" \
            --query "[?contains(publicIps, '${{ matrix.vm_ip }}')].name" \
            -o tsv | head -n 1)
          if [ -z "$VM_NAME" ]; then
            echo "ERROR: Could not find VM with IP ${{ matrix.vm_ip }} in resource group rg-upstream-prod"
            exit 1
          fi
          az vm user update \
            --resource-group "rg-upstream-prod" \
            --name "$VM_NAME" \
            --username azureuser \
            --ssh-key-value "$PUB_KEY"

      - name: Wait for VM SSH to be ready
        run: |
          SSH_READY=false
          for i in $(seq 1 20); do
            if ssh -i ~/.ssh/id_rsa -o ConnectTimeout=5 -o StrictHostKeyChecking=no \
                 azureuser@${{ matrix.vm_ip }} "echo ready"; then
              SSH_READY=true
              break
            fi
            echo "Attempt $i: SSH not ready yet, retrying in 15s..."
            sleep 15
          done
          if [ "$SSH_READY" != "true" ]; then
            echo "ERROR: SSH failed to connect after all attempts"
            exit 1
          fi

      - name: Copy app files to VM
        run: |
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            upstream_streamlit.py \
            upstream_integration.py \
            requirements.txt \
            azureuser@${{ matrix.vm_ip }}:/opt/upstream/app/

      - name: Install dependencies & restart service
        run: |
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no azureuser@${{ matrix.vm_ip }} << 'REMOTE'
            set -e
            echo "==> Installing Python dependencies..."
            /opt/upstream/venv/bin/pip install -r /opt/upstream/app/requirements.txt --quiet

            echo "==> Restarting upstream service..."
            sudo systemctl restart upstream

            echo "==> Service status:"
            sudo systemctl is-active upstream

            echo "==> Deploy complete on $(hostname)"
          REMOTE

      - name: Health check
        run: |
          sleep 5
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no azureuser@${{ matrix.vm_ip }} \
            "curl -sf http://localhost:8501/_stcore/health && echo 'Health OK' || echo 'Health check failed'"

  # ── Job 3: Verify Public Endpoint ───────────────────────────────────────────
  verify:
    name: Verify Public Endpoint
    runs-on: ubuntu-latest
    needs: [terraform, deploy]
    permissions: {}

    steps:
      - name: Check load balancer health endpoint
        run: |
          LB_IP="${{ needs.terraform.outputs.lb_ip }}"
          HEALTH_URL="http://${LB_IP}:8501/_stcore/health"
          MAX_RETRIES=20
          RETRY_DELAY=10
          CURL_TIMEOUT=10
          echo "Checking health endpoint: ${HEALTH_URL}"
          SUCCESS=false
          for i in {1..20}; do
            echo "Attempt ${i}/${MAX_RETRIES}..."
            if curl -sf --max-time "${CURL_TIMEOUT}" "${HEALTH_URL}"; then
              echo "Health check passed!"
              SUCCESS=true
              break
            fi
            echo "Not healthy yet, waiting ${RETRY_DELAY}s..."
            sleep "${RETRY_DELAY}"
          done
          if [ "$SUCCESS" != "true" ]; then
            echo "ERROR: Health endpoint ${HEALTH_URL} did not become healthy after ${MAX_RETRIES} attempts ($((MAX_RETRIES * RETRY_DELAY))s total)."
            echo "Diagnostics:"
            curl -v --max-time "${CURL_TIMEOUT}" "${HEALTH_URL}" || true
            exit 1
          fi
